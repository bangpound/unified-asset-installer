<?php

namespace PatternLab\Composer;

use Composer\Package\PackageInterface;
use Composer\Script\Event;
use Symfony\Component\Finder\Finder;
use Symfony\Component\Finder\SplFileInfo;

class PackageEventListener extends AbstractListener
{
    public function postAutoloadDump(Event $event)
    {
        // This method is called twice. Run it only once.
        if (!$this->runPostAutoloadDump) {
            return;
        }

        $this->runPostAutoloadDump = false;

        $event->getIO()->write('<info>Generating pattern engine and event listener locators</info>');
        $packages = array_filter($event->getComposer()->getRepositoryManager()
          ->getLocalRepository()->getCanonicalPackages(), function (PackageInterface $package) {
            return strpos($package->getType(), 'patternlab-') === 0;
        });

        $listeners = $this->getListeners($packages);
        $file = $this->packageDir.'/listeners.php';
        $listenersFile = <<<EOF
<?php

// listeners.php @generated by Pattern Lab

return array(

EOF;
        $listenersFile .= self::exportArray($listeners);
        $listenersFile .= ");\n";
        file_put_contents($file, $listenersFile);

        $patternEngines = $this->getPatternEngines($packages);
        $patternEngines = array_map(function ($patternEngine) {
            return var_export($patternEngine, true);
        }, $patternEngines);
        $file = $this->packageDir.'/patternengines.php';
        $patternEnginesFiles = <<<EOF
<?php

// patternengines.php @generated by Pattern Lab

return array(

EOF;
        $patternEnginesFiles .= self::exportArray($patternEngines);
        $patternEnginesFiles .= ");\n";
        file_put_contents($file, $patternEnginesFiles);
    }

    protected function getPatternEngines($packages)
    {
        $service = [
        ];

        /** @var PackageInterface $package */
        foreach ($packages as $package) {
            $pathBase = $this->packageDir.'/'.$package->getName();
            if ($package->getType() === 'patternlab-patternengine') {
                $service = array_merge($service, self::findPatternEngineRule($pathBase));
            }
        }

        return $service;
    }

    /**
     * @param $packages
     *
     * @return array
     */
    protected function getListeners($packages)
    {
        $service = [
        ];

        /** @var PackageInterface $package */
        foreach ($packages as $package) {
            $pathBase = $this->packageDir.'/'.$package->getName();
            $service = array_merge($service, self::findListeners($pathBase));
        }

        return $service;
    }

    /**
     * Scan the package for a listener.
     *
     * @param $pathPackage string     the path for the package
     *
     * @return array
     */
    private static function findListeners($pathPackage)
    {
        // set-up a finder to find the listener
        $finder = new Finder();
        $finder->files()->name('PatternLabListener.php')->in($pathPackage);

        // iterate over the returned objects

        $listenerList = [];

        /** @var SplFileInfo $file */
        foreach ($finder as $file) {

            // create the name
            $classes = self::findClasses($file->getPathname());
            $listenerName = '\\'.$classes[0];

            // check to see what we should do with the listener info
            $listenerList[] = $listenerName;
        }

        return $listenerList;
    }

    /**
     * Scan the package for a pattern engine rule.
     *
     * @param  $pathPackage string the path for the package
     *
     * @return array
     */
    private static function findPatternEngineRule($pathPackage)
    {
        // set-up a finder to find the listener
        $finder = new Finder();
        $finder->files()->name('PatternEngineRule.php')->in($pathPackage);

        // iterate over the returned objects

        $patternEngineList = [];

        /** @var SplFileInfo $file */
        foreach ($finder as $file) {

            // create the name
            $classes = self::findClasses($file->getPathname());
            $patternEngineName = '\\'.$classes[0];

            // check to see what we should do with the listener info
            $patternEngineList[] = $patternEngineName;
        }

        return $patternEngineList;
    }

    /**
     * Extract the classes in the given file.
     *
     * @param string $path The file to check
     *
     * @return array The found classes
     */
    private static function findClasses($path)
    {
        $contents = file_get_contents($path);
        $tokens = token_get_all($contents);

        $classes = array();

        $namespace = '';
        for ($i = 0; isset($tokens[$i]); ++$i) {
            $token = $tokens[$i];

            if (!isset($token[1])) {
                continue;
            }

            $class = '';

            switch ($token[0]) {
                case T_NAMESPACE:
                    $namespace = '';
                    // If there is a namespace, extract it
                    while (isset($tokens[++$i][1])) {
                        if (in_array($tokens[$i][0], array(T_STRING, T_NS_SEPARATOR))) {
                            $namespace .= $tokens[$i][1];
                        }
                    }
                    $namespace .= '\\';
                    break;
                case T_CLASS:
                case T_INTERFACE:
                case T_TRAIT:
                    // Skip usage of ::class constant
                    $isClassConstant = false;
                    for ($j = $i - 1; $j > 0; --$j) {
                        if (!isset($tokens[$j][1])) {
                            break;
                        }

                        if (T_DOUBLE_COLON === $tokens[$j][0]) {
                            $isClassConstant = true;
                            break;
                        } elseif (!in_array($tokens[$j][0], array(T_WHITESPACE, T_DOC_COMMENT, T_COMMENT))) {
                            break;
                        }
                    }

                    if ($isClassConstant) {
                        break;
                    }

                    // Find the classname
                    while (isset($tokens[++$i][1])) {
                        $t = $tokens[$i];
                        if (T_STRING === $t[0]) {
                            $class .= $t[1];
                        } elseif ('' !== $class && T_WHITESPACE === $t[0]) {
                            break;
                        }
                    }

                    $classes[] = ltrim($namespace.$class, '\\');
                    break;
                default:
                    break;
            }
        }

        return $classes;
    }
}
